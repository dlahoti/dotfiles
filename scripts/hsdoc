#!/usr/bin/env runhaskell
{-# LANGUAGE FlexibleInstances #-}
module Main (main) where

import GHC.PackageDb

import System.Environment (getArgs)
import System.Process (readProcess, spawnProcess)
import System.FilePath ((</>), (<.>))
import System.IO (hPutStrLn, stderr)
import System.Exit (exitFailure)
import Control.Monad (when)

import qualified Data.ByteString as B
import qualified Data.Text as T
import qualified Data.Text.Encoding as T

instance BinaryStringRep String where
  fromStringRep = T.unpack . T.decodeUtf8
  toStringRep = T.encodeUtf8 . T.pack
type InstalledPackageInfo' = InstalledPackageInfo String String String String String

findPkgs :: String -> [InstalledPackageInfo'] -> [InstalledPackageInfo']
findPkgs mod = filter $ (ExposedModule mod Nothing Nothing `elem`) . exposedModules

main = do
  dbfile <- init <$> readProcess "ghc" ["--print-global-package-db"] ""
  inf <- readPackageDbForGhc $ dbfile </> "package.cache"
  argv <- getArgs
  let pkgs' = filter ((== head argv) . packageName) inf
      (pkgs, mod) = case (argv, pkgs') of
        ("-":a:_,  _) -> (findPkgs   a inf, Just a)
        (    a:_, []) -> (findPkgs   a inf, Just a)
        (  _:a:_,  _) -> (pkgs',            Just a)
        (      _,  _) -> (pkgs',            Nothing)
      modfile = case mod of
        Just a  -> fmap (\c -> if c == '.' then '-' else c) a <.> "html"
        Nothing -> "index.html"
      htmls = fmap (</> modfile) . haddockHTMLs =<< pkgs
  when (null argv) $ do
    hPutStrLn stderr "error: must provide a package name"
    exitFailure
  when (null htmls) $ do
    hPutStrLn stderr "error: no such docs found"
    exitFailure
  sequence_ $ spawnProcess "xdg-open" . (:[]) <$> htmls
